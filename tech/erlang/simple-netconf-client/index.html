<!DOCTYPE html>
<html lang="zh-cn">
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta property="og:title" content=" Erlang Netconf Client &middot;  Hao Ruan" />
  
  <meta name="theme-color" content="#333" />
 
  <meta property="og:site_name" content="Hao Ruan" />
  <meta property="og:url" content="https://ruanhao.github.io/tech/erlang/simple-netconf-client/" />
  
  
  <meta property="og:type" content="article" />
  
  <meta property="og:article:author" content="https://facebook.com/ruanhao1116" />
  
  <meta property="og:article:published_time" content="2017-11-19T13:13:12&#43;08:00" />
  
  
  <meta name="og:description" content="前言 公司的项目通过 Netconf 协议从网络设备获取配置，管理，运行参数等信息。 使用 Opendaylight 这个平台实现基于 Netconf 的交互操作。
在 SDN 领域，ODL 可以算得上是集大成者，也提供了一些很棒的插件，比如实现 YANG 与 Java 对象之间的映射绑定。 由于当初对 Netconf 协议了解不多，而 ODL 正好在这一领域提供了一揽子解决方案，为了快速开展项目，就选择了它。 但其实在整个项目中 ODL 只是充当了 Netconf client 的角色，很多模块和内置插件虽然启动了，但是完全没有用到， 考虑到 Docker 和 AWS 上的部署与运维，使用 ODL 的成本就显得很高，因为整个 ODL 体积太庞大，而且需要占用大量内存。
我打算寻找一种简单的 Netconf client 实现方案替代 ODL 。
替代方案 其实相比实现 Netconf server ，client 端相对简单一些，只需要实现 Netconf 协议的编解码和消息处理逻辑。
在网上搜索一番之后，发现了 Erlang Common Test 这个框架， 其中包含一个测试套件 ct_netconfc 。
看了一下帮助文档，发现 ct_netconfc 实现了 RFC 4741 ，完全可以为我所用。 而且实现了 RFC 4742 ，即基于 SSH 传输协议。 我们的项目是基于 TCP 的，只需要将传输协议改造下即可。" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:url" content="https://ruanhao.github.io/tech/erlang/simple-netconf-client/" />
  <meta name="twitter:site" content="@" />
  <meta name="twitter:creator" content="@" />

  <title>
     Erlang Netconf Client &middot;  Hao Ruan
  </title>

  <link rel="stylesheet" href="https://ruanhao.github.io/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://ruanhao.github.io/css/main.css" />
  <link rel="stylesheet" href="https://ruanhao.github.io/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://ruanhao.github.io/css/github.css" />
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400" type="text/css">
  <link rel="stylesheet" href="https://ruanhao.github.io//style.css">
  <link rel="shortcut icon" href="https://ruanhao.github.io/images/favicon.ico" />
  <link rel="apple-touch-icon" href="https://ruanhao.github.io/images/apple-touch-icon.png" />
  
</head>
<body>
    <header class="global-header"  style="background-image:url( /images/bg.png )">
    <section class="header-text">
      <h1><a href="https://ruanhao.github.io/">Hao Ruan</a></h1>
      
      <div class="tag-line">
        用简单的文字记录生活与技术
      </div>
      
      
      <a href="https://ruanhao.github.io/" class="btn-header btn-back hidden-xs">
        <i class="fa fa-angle-left" aria-hidden="true"></i>
        &nbsp;Home
      </a>
      
      
    </section>
  </header>
  <main class="container">


<article>
  <header>
    <h1 class="text-primary">Erlang Netconf Client</h1>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2017-11-19T13:13:12&#43;08:00">
          Nov 19, 2017
        </time>
      </div>
      <div class="pull-right">
        
      </div>
    </div>
  </header>
  <section>
    

<h2 id="前言">前言</h2>

<p>公司的项目通过 <a href="https://en.wikipedia.org/wiki/NETCONF">Netconf</a> 协议从网络设备获取配置，管理，运行参数等信息。
使用 <a href="https://www.opendaylight.org/">Opendaylight</a> 这个平台实现基于 Netconf 的交互操作。</p>

<p>在 SDN 领域，ODL 可以算得上是集大成者，也提供了一些很棒的插件，比如实现 <a href="https://en.wikipedia.org/wiki/YANG">YANG</a> 与 Java 对象之间的映射绑定。
由于当初对 Netconf 协议了解不多，而 ODL 正好在这一领域提供了一揽子解决方案，为了快速开展项目，就选择了它。
但其实在整个项目中 ODL 只是充当了 Netconf client 的角色，很多模块和内置插件虽然启动了，但是完全没有用到，
考虑到 Docker 和 AWS 上的部署与运维，使用 ODL 的成本就显得很高，因为整个 ODL 体积太庞大，而且需要占用大量内存。</p>

<p>我打算寻找一种简单的 Netconf client 实现方案替代 ODL 。</p>

<h2 id="替代方案">替代方案</h2>

<p>其实相比实现 Netconf server ，client 端相对简单一些，只需要实现 Netconf 协议的编解码和消息处理逻辑。</p>

<p>在网上搜索一番之后，发现了 <a href="http://erlang.org/doc/man/common_test.html">Erlang Common Test</a> 这个框架，
其中包含一个测试套件 <a href="http://erlang.org/doc/man/ct_netconfc.html">ct_netconfc</a> 。</p>

<p>看了一下帮助文档，发现 ct_netconfc 实现了 <a href="https://tools.ietf.org/html/rfc4741">RFC 4741</a> ，完全可以为我所用。
而且实现了 <a href="https://tools.ietf.org/html/rfc4742">RFC 4742</a> ，即基于 SSH 传输协议。
我们的项目是基于 TCP 的，只需要将传输协议改造下即可。</p>

<h2 id="代码改造">代码改造</h2>

<p>ct_netconfc 代码写得很简练，重构过程还算轻松：</p>

<ol>
<li>将编解码的逻辑从框架中抽出</li>
<li>使用 TCP 作为底层传输协议</li>
<li>将 Netconf 连接抽象成 Erlang 进程 (gen_server)</li>
</ol>

<p><a href="https://github.com/ruanhao/simple-netconf-client">Talk is cheap, show me the code</a></p>

<h2 id="后记">后记</h2>

<p>其实最开始，在参考了 <a href="http://www.tail-f.com/confd-netconf-server/">ConfD</a> 的源码后，用 Python 写过一个 demo ，
已经实现了最基本的功能。但是心里始终有个想法，就是希望用 Erlang 来实现。</p>

<p>虽然 Python 在越来越多的领域中使用，而且表现出色，但我认为它的长处在于系统管理，快速建模，数据挖掘等场景。
而多并发 (Erlang process) ，协议处理 (bit syntax) ，传输 (gen_tcp) 这些方面都是 Erlang 的强项。</p>

<p>还有一个原因就是我非常喜欢 Erlang 这门语言，语法简单朴实却功能强大，很有北欧人的性格特征。</p>

<p>已经好久没写 Erlang 了，是时候重拾 Erlang 了。</p>

  </section>
  <footer>
    
    <hr/>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname = 'ruanhao';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    
    <section class="author-info row">
      <div class="author-avatar col-md-2">
        
        <img alt="Author Avatar" src="/images/avatar.jpg" />
        
      </div>
      <div class="author-meta col-md-6">
        
        <h1 class="author-name text-primary">Hao Ruan</h1>
        
        
        <div class="author-bio">software engineer @ Shanghai</div>
        
      </div>
      
    </section>
    <ul class="pager">
      
      <li class="previous"><a href="https://ruanhao.github.io/tech/web/oauth/"><span aria-hidden="true">&larr;</span> Older</a></li>
      
      
      <li class="next disabled"><a href="#">Newer <span aria-hidden="true">&rarr;</span></a></li>
      
    </ul>
  </footer>
</article>

  </main>
  <footer class="container global-footer">
    <div class="copyright-note pull-left">
      &copy; Copyright Hao Ruan
    </div>
    <div class="sns-links hidden-print">
  
  
  
  
  
  <a href="https://facebook.com/ruanhao1116" target="_blank">
    <i class="fa fa-facebook"></i>
  </a>
  
  
  <a href="https://github.com/ruanhao" target="_blank">
    <i class="fa fa-github"></i>
  </a>
  
  
  
  <a href="https://linkedin.com/in/ruanhao1116" target="_blank">
    <i class="fa fa-linkedin"></i>
  </a>
  
  
</div>

  </footer>

  <script src="https://ruanhao.github.io/js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-109678845-1', 'auto');
    ga('send', 'pageview');
  </script>
  
  
</body>
</html>

